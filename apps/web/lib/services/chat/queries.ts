import { useInfiniteQuery } from "@tanstack/react-query";
import { isToday, isYesterday, subMonths, subWeeks } from 'date-fns';
import React from "react";

const CHATS_MOCK_DATA = [
  {
    id: "t1",
    title: "Project Roadmap Discussion",
    lastMessage:
      "Let's prioritize the authentication features for the next sprint.",
    timestamp: new Date().setHours(new Date().getHours() - 2),
  },
  {
    id: "t2",
    title: "API Documentation Review",
    lastMessage:
      "The endpoint descriptions need more detail about rate limiting.",
    timestamp: new Date().setHours(new Date().getHours() - 5),
  },
  {
    id: "t3",
    title: "Frontend Bug Analysis",
    lastMessage:
      "I found the issue - we need to handle the null state in the user profile component.",
    timestamp: new Date().setHours(new Date().getHours() - 8),
  },
  {
    id: "y1",
    title: "Database Schema Design",
    lastMessage:
      "Let's add indexes to improve query performance on these tables.",
    timestamp: new Date().setDate(new Date().getDate() - 1),
  },
  {
    id: "y2",
    title: "Performance Optimization",
    lastMessage:
      "The lazy loading implementation reduced initial load time by 40%.",
    timestamp: new Date().setDate(new Date().getDate() - 1),
  },
  {
    id: "w1",
    title: "Authentication Flow",
    lastMessage: "We should implement the OAuth2 flow with refresh tokens.",
    timestamp: new Date().setDate(new Date().getDate() - 3),
  },
  {
    id: "w2",
    title: "Component Library",
    lastMessage:
      "These new UI components follow the design system guidelines perfectly.",
    timestamp: new Date().setDate(new Date().getDate() - 5),
  },
  {
    id: "w3",
    title: "UI/UX Feedback",
    lastMessage:
      "The navigation redesign received positive feedback from the test group.",
    timestamp: new Date().setDate(new Date().getDate() - 6),
  },
  {
    id: "m1",
    title: "Initial Project Setup",
    lastMessage:
      "All the development environments are now configured consistently.",
    timestamp: new Date().setDate(new Date().getDate() - 15),
  },
  {
    id: "m2",
    title: "Requirements Gathering",
    lastMessage:
      "The stakeholders approved the feature specifications document.",
    timestamp: new Date().setDate(new Date().getDate() - 22),
  },
  {
    id: "m3",
    title: "Tech Stack Selection",
    lastMessage:
      "We decided on Next.js, Tailwind, and a serverless backend architecture.",
    timestamp: new Date().setDate(new Date().getDate() - 28),
  },
  {
    id: "m4",
    title: "Project Planning",
    lastMessage: "We need to create a project plan for the next sprint.",
    timestamp: new Date().setDate(new Date().getDate() - 30),
  },
  {
    id: "q1",
    title: "Deployment Strategy",
    lastMessage: "Let's discuss whether blue-green deployment is viable here.",
    timestamp: new Date().setDate(new Date().getDate() - 45),
  },
  {
    id: "q2",
    title: "Security Audit",
    lastMessage: "Vulnerability scans highlighted some minor issues we must address.",
    timestamp: new Date().setDate(new Date().getDate() - 50),
  },
  {
    id: "q3",
    title: "User Analytics Report",
    lastMessage: "Analytics show increased user retention with the new onboarding flow.",
    timestamp: new Date().setDate(new Date().getDate() - 55),
  },
  {
    id: "q4",
    title: "Backend Refactoring",
    lastMessage: "Refactoring the services has significantly improved code maintainability.",
    timestamp: new Date().setDate(new Date().getDate() - 60),
  },
  {
    id: "q5",
    title: "Testing Framework",
    lastMessage: "We agreed to use Jest and Cypress for our comprehensive testing strategy.",
    timestamp: new Date().setDate(new Date().getDate() - 65),
  },
  {
    id: "q6",
    title: "CI/CD Pipeline",
    lastMessage: "Automated deployments have reduced our manual overhead dramatically.",
    timestamp: new Date().setDate(new Date().getDate() - 70),
  },
  ...Array.from({ length: 38 }, (_, i) => ({
    id: `auto-${i + 1}`,
    title: `Automated Chat ${i + 1}`,
    lastMessage: `This is an autogenerated message for chat ${i + 1}.`,
    timestamp: new Date().setDate(new Date().getDate() - (75 + i)),
  })),
];

type Chat = typeof CHATS_MOCK_DATA[number];

export function useChats() {
  const query = useInfiniteQuery({
    queryKey: ["infinite-chats"],
    queryFn: async ({ pageParam = undefined }) => {
      await new Promise((resolve) => setTimeout(resolve, 1000)); // Simulate network delay
      return CHATS_MOCK_DATA
    },
    initialPageParam: undefined,
    getNextPageParam: (lastPage, allPages) => undefined,
  });

  return {
    ...query,
    hasData: query.data?.pages.every((page) => page.length > 0),
  }
}

type ChatsQueryResult = ReturnType<typeof useChats>;

export enum ChatGroupPeriod {
  TODAY = "today",
  YESTERDAY = "yesterday",
  LAST_WEEK = "last-week",
  LAST_MONTH = "last-month",
  OLDER = "older",
}

type GroupedChats = {
  [key in ChatGroupPeriod]?: Chat[];
};

type GroupedChatsQueryResult = Omit<ChatsQueryResult, "data"> & {
  data: GroupedChats | undefined;
};

export function groupChatsByTimePeriod(chats: Chat[]): GroupedChats {
  const now = new Date();
  const oneWeekAgo = subWeeks(now, 1);
  const oneMonthAgo = subMonths(now, 1);

  return chats.reduce(
    (groups, chat) => {
      const chatDate = new Date(chat.timestamp);

      if (isToday(chatDate)) {
        if (!groups[ChatGroupPeriod.TODAY]) groups[ChatGroupPeriod.TODAY] = [];
        groups[ChatGroupPeriod.TODAY].push(chat);
      } else if (isYesterday(chatDate)) {
        if (!groups[ChatGroupPeriod.YESTERDAY]) groups[ChatGroupPeriod.YESTERDAY] = [];
        groups[ChatGroupPeriod.YESTERDAY].push(chat);
      } else if (chatDate > oneWeekAgo) {
        if (!groups[ChatGroupPeriod.LAST_WEEK]) groups[ChatGroupPeriod.LAST_WEEK] = [];
        groups[ChatGroupPeriod.LAST_WEEK].push(chat);
      } else if (chatDate > oneMonthAgo) {
        if (!groups[ChatGroupPeriod.LAST_MONTH]) groups[ChatGroupPeriod.LAST_MONTH] = [];
        groups[ChatGroupPeriod.LAST_MONTH].push(chat);
      } else {
        if (!groups[ChatGroupPeriod.OLDER]) groups[ChatGroupPeriod.OLDER] = [];
        groups[ChatGroupPeriod.OLDER].push(chat);
      }

      return groups;
    },
    {} as GroupedChats,
  );
}

// group chats by time period
export function useGroupedChats() {
  const { data, ...rest } = useChats();
  const allChats = React.useMemo(() => data?.pages.flat() || [], [data]);

  const groupedChats: GroupedChats = React.useMemo(() => groupChatsByTimePeriod(allChats), [allChats]);
  return {
    ...rest,
    data: groupedChats,
  }
}